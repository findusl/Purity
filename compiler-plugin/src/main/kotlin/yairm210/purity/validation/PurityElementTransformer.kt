@file:OptIn(ObsoleteDescriptorBasedAPI::class)
package yairm210.purity.validation

import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
import org.jetbrains.kotlin.descriptors.DescriptorVisibilities
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.backend.js.utils.parentEnumClassOrNull
import org.jetbrains.kotlin.ir.declarations.IrProperty
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.expressions.IrConst
import org.jetbrains.kotlin.ir.expressions.IrVararg
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.name.FqName
import yairm210.purity.PurityConfig
import yairm210.purity.boilerplate.DebugLogger

/** 
 * Iterates over all functions in the IR.
 * For each function, creates a CheckFunctionPurityVisitor to raise errors for that specific function.
 * */
internal class PurityElementTransformer(
    private val debugLogger: DebugLogger,
    private val purityConfig: PurityConfig,
) : IrElementTransformerVoid() {
    
    // These are created behind the scenes for every class, don't warn for them
    private val autogeneratedFunctions = setOf(
        "equals",
        "hashCode",
        "toString"
    )
    private val enumAutogeneratedFunctions = setOf(
        "values",
        "valueOf",
        "compareTo",
        "clone"
    )
    
    private fun isAutogeneratedFunction(function: IrSimpleFunction): Boolean {
        val name = function.name.asString()
        return autogeneratedFunctions.contains(name) 
                || name.startsWith('<') // auto-generated functions like <init>, <get-name>, <set-name>
                || function.parentEnumClassOrNull != null && (name in enumAutogeneratedFunctions) // Enum values function
                || function.parentClassOrNull?.isData == true && ExpectedFunctionPurityChecker.componentRegex.matches(name) // componentN functions for data classes
                || function.parentClassOrNull?.isData == true && name == "copy" // copy function for data classes

    }
    
    private fun isSuppressed(declaration: IrSimpleFunction): Boolean {
        val allInheritedAnnotations = declaration.annotations + getAllOverriddenFunctions(declaration).flatMap { it.annotations }
        val suppressFqName = FqName("kotlin.Suppress")
        val suppressAnnotations = allInheritedAnnotations.filter { it.isAnnotation(suppressFqName) }
        if (suppressAnnotations.isEmpty()) return false
        
        // getAnnotationArgumentValue does not work for varargs, so we find the vararg
        // .mapNotNull {} instead of direct indexing because Suppress can be called with zero parameters
        @Suppress("UNCHECKED_CAST")
        val suppressParameters: List<String> = suppressAnnotations
            .mapNotNull { it.arguments[0] as? IrVararg }
            .flatMap { it.elements }
            .mapNotNull { (it as? IrConst)?.value as? String }

        return suppressParameters.contains("purity")
    }

    override fun visitProperty(declaration: IrProperty): IrStatement {
        if (declaration.visibility != DescriptorVisibilities.PRIVATE && declaration.hasAnnotation(Annotations.Cache)){
            val message = "Variable \"${declaration.name}\" is marked as \"@Cache\", but is public - this annotation is reserved for private variables"
            
            debugLogger.messageCollector.report(
                CompilerMessageSeverity.ERROR, message,
                location = getLocationForExpression(declaration.fileEntry, declaration)
            )
        }
        return super.visitProperty(declaration)
    }
    
    override fun visitSimpleFunction(declaration: IrSimpleFunction): IrStatement {
        if (isAutogeneratedFunction(declaration)) return super.visitSimpleFunction(declaration)

        // Skip interface/abstract functions that are not implemented
        if (declaration.body == null) return super.visitSimpleFunction(declaration)

        if (isSuppressed(declaration)) return super.visitSimpleFunction(declaration)

        val functionDeclaredPurity = when {
            ExpectedFunctionPurityChecker.isMarkedAsPure(declaration, purityConfig) -> FunctionPurity.Pure
            ExpectedFunctionPurityChecker.isReadonly(declaration, purityConfig) -> FunctionPurity.Readonly
            else -> FunctionPurity.None
        }
        val messageCollector = debugLogger.messageCollector

        val visitor = CheckFunctionPurityVisitor(declaration, functionDeclaredPurity, messageCollector, purityConfig)
        declaration.accept(visitor, null)

        val actualPurity = visitor.actualFunctionPurity()

        if (visitor.hasExpectCompileErrorAnnotation) { // opposite land - fail is success, success is fail
            // We use hasErrored and not function purity, because there are other kinds of exceptions
            // For example, passing a non-readonly variable to a @Readonly parameter doesn't violate purity, but it is an error!
            if (!visitor.hasErrored) 
                messageCollector.report(
                    CompilerMessageSeverity.ERROR,
                    "Function \"${declaration.name}\" should fail on purity checks, but succeeds!",
                    location = getLocationForExpression(declaration, declaration)
                )

            return super.visitSimpleFunction(declaration)
        }

        val shouldWarnForPossibleAnnotations =
            functionDeclaredPurity < actualPurity
                && purityConfig.warnOnPossibleAnnotations
                && !isAutogeneratedFunction(declaration)
                && !declaration.overriddenSymbols.any() // not inherited
                && declaration.parentClassOrNull?.isInterface != true
        
        if (shouldWarnForPossibleAnnotations) {
            // if equal, no message; If less that declared, we already warn for each individual violation
            val message = when (actualPurity) {
                FunctionPurity.Pure -> "Function \"${declaration.name}\" can be marked with @Pure to indicate it is pure"
                FunctionPurity.Readonly -> "Function \"${declaration.name}\" can be marked with @Readonly to indicate it is readonly"
                else -> throw Exception("Unexpected function purity: $actualPurity")
            }

            debugLogger.messageCollector.report(
                CompilerMessageSeverity.WARNING, message,
                location = getLocationForExpression(declaration, declaration)
            )
        }

        return super.visitSimpleFunction(declaration)
    }

}